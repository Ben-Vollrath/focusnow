-- challenge_category enum
CREATE TYPE challenge_category AS ENUM ('daily', 'one_time', 'streaks');

-- levels table
CREATE TABLE levels (
  level INT PRIMARY KEY,
  exp_required INT NOT NULL,
  name TEXT NOT NULL,
  icon TEXT
);
ALTER TABLE levels ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated read access"
  ON levels
  FOR SELECT
  TO authenticated
  USING (true);

-- challenges table
CREATE TABLE challenges (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  category challenge_category,
  condition JSON NOT NULL,
  reward_xp INT,
  is_repeatable BOOLEAN DEFAULT FALSE
);
ALTER TABLE challenges ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated read access"
  ON challenges
  FOR SELECT
  TO authenticated
  USING (true);

-- users table
CREATE TABLE users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  user_idx INT GENERATED BY DEFAULT AS IDENTITY UNIQUE,
  username TEXT NOT NULL,
  level INT REFERENCES levels(level),
  xp INT DEFAULT 0,
  total_study_time INT DEFAULT 0
);
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can read their own data"
  ON users
  FOR SELECT
  TO authenticated
  USING (id = auth.uid());


-- goals table
CREATE TABLE goals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  target_hours FLOAT NOT NULL,
  target_date DATE,
  progress FLOAT DEFAULT 0,
  completed BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT now(),
  xp_reward INT
);
ALTER TABLE goals ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can read their own goals"
  ON goals
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- study_sessions table
CREATE TABLE study_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ NOT NULL,
  duration INT
);
ALTER TABLE study_sessions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can read their own study sessions"
  ON study_sessions
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- study_days table
CREATE TABLE study_days (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  study_date DATE NOT NULL,
  total_study_time INT DEFAULT 0,
  streak_day INT DEFAULT 0,
  UNIQUE(user_id, study_date)  -- ensures one entry per day per user
);
ALTER TABLE study_days ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can read their own study days"
  ON study_days
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

-- challenge_progress table
CREATE TABLE challenge_progress (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  challenger_id UUID REFERENCES challenges(id) ON DELETE CASCADE,
  completed BOOLEAN DEFAULT FALSE,
  progress FLOAT DEFAULT 0,
  last_updated TIMESTAMPTZ DEFAULT now()
);
ALTER TABLE challenge_progress ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can read their own challenge progress"
  ON challenge_progress
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());


--- Create new user on auth signup

CREATE OR REPLACE FUNCTION handle_new_auth_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id)
  VALUES (NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_auth_user();

--- Username Generator

CREATE TABLE username_words (
  word TEXT,
  type TEXT, 
  PRIMARY KEY (type, word)
);

-- Insert with manual IDs
INSERT INTO username_words (type, word) VALUES
  ('verb', 'running'),
  ('verb', 'coding'),
  ('verb', 'dancing'),
  ('animal', 'tiger'),
  ('animal', 'fox'),
  ('animal', 'panda');



CREATE OR REPLACE FUNCTION assign_structured_username()
RETURNS TRIGGER AS $$
DECLARE
  verb TEXT;
  animal TEXT;
BEGIN
  -- Pick a random verb
  SELECT word INTO verb
  FROM public.username_words
  WHERE type = 'verb'
  ORDER BY random()
  LIMIT 1;

  -- Pick a random animal
  SELECT word INTO animal
  FROM public.username_words
  WHERE type = 'animal'
  ORDER BY random()
  LIMIT 1;

  -- Combine into username
  NEW.username := LOWER(verb || ' ' || animal);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;



CREATE TRIGGER structured_username_trigger
  BEFORE INSERT ON users
  FOR EACH ROW
  WHEN (NEW.username IS NULL)
  EXECUTE FUNCTION assign_structured_username();
